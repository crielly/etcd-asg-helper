import boto3
import logging
import os
import sys

from botocore.vendored import requests

_LOGGER = logging.Logger('etcdasghelper')

from constants import (
    PROJECT_NAME, ENV_NAME, ETCD_TAG_NAME, ETCD_PEER_PORT, ZONE_ID, SRV_RECORD_NAME, 
    DOMAIN_NAME, SRV_TTL, LOG_LEVEL, ETCD_CLIENT_CERT_SSM_PATH, ETCD_CLIENT_KEY_SSM_PATH,
    ETCD_API_DNS, ETCD_ROOT_CA_CERT_SSM_PATH, ETCD_CLIENT_LB_PORT
)

def get_instances(client, config, return_attribute):
    """Return a list of private DNS addresses for servers matching project, 
    environment, id tag name (which identified it as an etcd or master server),
    and instance state (pending/running)
    """

    servers = []

    _LOGGER.info(
        "Finding instances from Project {} - Environment {} - tagged {}".format(
            config.get(PROJECT_NAME, {}),
            config.get(ENV_NAME, {}),
            config.get(ETCD_TAG_NAME, {})
        ))

    resp = client.describe_instances(
        Filters=[
            {
                'Name': 'tag:Environment',
                'Values': [
                    config.get(ENV_NAME, {})
                    ]
            },
            {
                'Name': 'tag:Project',
                'Values':[
                    config.get(PROJECT_NAME, {})
                    ]
            },
            {
                'Name': 'tag:{}'.format(config.get(ETCD_TAG_NAME, {})),
                'Values': [
                    'True', 'true'
                    ]
            },
            {
                'Name': 'instance-state-name',
                'Values': [
                    'running', 'pending'
                ]
            }
        ]
    )

    for i in resp['Reservations']:
        servers.append(
            i['Instances'][0][return_attribute]
        )

    _LOGGER.info("Found instances: {}".format(servers))
    
    return servers

def construct_srv_record_content(config, etcd_members):
    """
    Construct a list of dictionaries that will be our etcd SRV record's contents.
    Method assumes you do not want priority, weight, or port numbers to differ
    between etcd members
    """

    members = []

    for m in etcd_members:
        members.append(
            {
                'Value': "0 0 {} {}".format(
                    config.get(ETCD_PEER_PORT, {}), m
                )
            }
        )

    _LOGGER.info("Constructed SRV record content: {}".format(members))
    return members

def upsert_etcd_srv_record(client, config, record_content):
    """
    Upsert a Route53 SRV record with the content generated by the 
    construct_srv_record_content method.
    """

    resp = client.change_resource_record_sets(
        HostedZoneId=config.get(ZONE_ID, {}),
        ChangeBatch={
            'Comment': 'Updating etcd SRV Record',
            'Changes': [
                {
                    'Action': 'UPSERT',
                    'ResourceRecordSet': {
                        'Name': "{}.{}".format(
                            config.get(SRV_RECORD_NAME, {}),
                            config.get(DOMAIN_NAME, {})
                        ),
                        'Type': 'SRV',
                        'TTL': int(config.get(SRV_TTL, {})),
                        'ResourceRecords': record_content
                    }
                }
            ]
        }
    )

    _LOGGER.info("Updating SRV Record {}.{} in zone {} with TTL of {}".format(
        config.get(SRV_RECORD_NAME, {}),
        config.get(DOMAIN_NAME, {}),
        config.get(ZONE_ID, {}),
        config.get(SRV_TTL, {})
    ))
    _LOGGER.info("Return Code: {}".format(
        resp['ResponseMetadata']['HTTPStatusCode']
    ))

# def get_etcd_client_cert_key(client, config):
#     """
#     Fetch etcd client certificate and private key and stash them in /tmp
#     """

#     cert = client.get_parameter(
#         Name=config.get(ETCD_CLIENT_CERT_SSM_PATH, {}),
#         WithDecryption=True
#     )['Parameter']['Value']

#     with open("/tmp/etcd_client_cert.pem", "w") as certfile:
#         certfile.write(cert)
#         os.chmod("/tmp/etcd_client_cert.pem", 0o600)

#     key = client.get_parameter(
#         Name=config.get(ETCD_CLIENT_KEY_SSM_PATH, {}),
#         WithDecryption=True
#     )['Parameter']['Value']

#     with open("/tmp/etcd_client_key.pem", "w") as keyfile:
#         keyfile.write(key)
#         os.chmod("/tmp/etcd_client_key.pem", 0o600)

#     cacert = client.get_parameter(
#         Name=config.get(ETCD_ROOT_CA_CERT_SSM_PATH, {}),
#         WithDecryption=True
#     )['Parameter']['Value']

#     with open("/tmp/etcd_cacert.pem", "w") as cacertfile:
#         cacertfile.write(cacert)
#         os.chmod("/tmp/etcd_cacert.pem", 0o600)

def update_etcd_cluster_state(client, config):
    resp = requests.get(
        'https://{}/health'.format(
            config.get(ETCD_API_DNS, {})
        ),
        verify=False
    )
    if resp.status_code == 200 and resp.json()['health'] == 'true':
        resp = client.put_parameter(
            Name='/{}/{}/etcd/initial-cluster-state'.format(
                config.get(PROJECT_NAME, {}),
                config.get(ENV_NAME, {})
            ),
            Overwrite=True,
            Type='SecureString',
            Value='existing',
        )
    else:
        resp = client.put_parameter(
            Name='/{}/{}/etcd/initial-cluster-state'.format(
                config.get(PROJECT_NAME, {}),
                config.get(ENV_NAME, {})
            ),
            Overwrite=True,
            Type='SecureString',
            Value='new',
        )

def get_etcd_members(config):
    members =  requests.get(
        'https://{}:{}/v2/members'.format(
            config.get(ETCD_API_DNS, {}),
            config.get(ETCD_CLIENT_LB_PORT, {})
        ),
        verify=False,
        timeout=10
    ).json()['members']

    _LOGGER.info("Found members: {}".format(
        members
    ))

    return members

def add_etcd_member(config, dns):

    payload = '{"peerURLs": ["https://{}:{}"]}'.format(
        dns,
        config.get(ETCD_PEER_PORT, {})
    )

    resp = requests.post(
        https://{}:{}/v2/members'.format(
            config.get(ETCD_API_DNS, {}),
            config.get(ETCD_CLIENT_LB_PORT, {})
        ),
        data=payload,
        verify=False
    )


def setup_logging():
    """Configure _LOGGER
    """
    _LOGGER.setLevel(logging.DEBUG)
    handler = logging.StreamHandler(sys.stdout)
    formatter = logging.Formatter('%(asctime)s : %(levelname)s - %(message)s')
    handler.setFormatter(formatter)
    _LOGGER.addHandler(handler)

def lambda_handler(event, context):
    """Entrypoint for AWS Lambda
    """
    setup_logging()

    config = {
        PROJECT_NAME: os.environ.get(PROJECT_NAME, {}),
        ENV_NAME: os.environ.get(ENV_NAME, {}),
        ZONE_ID: os.environ.get(ZONE_ID, {}),
        DOMAIN_NAME: os.environ.get(DOMAIN_NAME, {}),
        SRV_RECORD_NAME: os.environ.get(SRV_RECORD_NAME, {}),
        SRV_TTL: os.environ.get(SRV_TTL, {}),
        LOG_LEVEL: os.environ.get(LOG_LEVEL, {}),
        ETCD_PEER_PORT: os.environ.get(ETCD_PEER_PORT, {}),
        ETCD_CLIENT_LB_PORT: os.environ.get(ETCD_CLIENT_LB_PORT, {}),
        ETCD_TAG_NAME: os.environ.get(ETCD_TAG_NAME, {}),
        ETCD_CLIENT_CERT_SSM_PATH: os.environ.get(ETCD_CLIENT_CERT_SSM_PATH, {}),
        ETCD_CLIENT_KEY_SSM_PATH: os.environ.get(ETCD_CLIENT_KEY_SSM_PATH, {}),
        ETCD_ROOT_CA_CERT_SSM_PATH: os.environ.get(ETCD_ROOT_CA_CERT_SSM_PATH, {}),
        ETCD_API_DNS: os.environ.get(ETCD_API_DNS, {})
    }

    try:
        # Establish client connections
        route53 = boto3.client('route53')
        ec2 = boto3.client('ec2')
        ssm = boto3.client('ssm', region_name=os.environ.get('AWS_REGION'))

        # Fetch etcd client cert and key
        #get_etcd_client_cert_key(ssm, config)

        # Find current etcd servers
        etcdservers = get_instances(ec2, config, "PrivateDnsName")

        update_etcd_cluster_state(ssm, config)

        etcdmembers = get_etcd_members(config)


        #Purge any dead peers
        if etcdmembers and etcdservers:

            for s in etcdservers:
                _LOGGER.info("Examining etcd server with dns {}".format(s))
                if not any(m['name'] == s for m in etcdmembers):
                    add_etcd_member(s)

            for m in etcdmembers:
                _LOGGER.info("Examining etcd member {} with dns {}".format(
                    m['id'], m['name']
                ))
                if m['name'] not in etcdservers:
                    _LOGGER.info(
                        "{} is a dead peer with id {}, removing".format(
                            m['name'], m['id']
                        )
                    )
                    requests.delete(
                        'https://{}:{}/v2/members/{}'.format(
                            config.get(ETCD_API_DNS, {}),
                            config.get(ETCD_CLIENT_LB_PORT, {}),
                            m['id']
                        ),
                        cert=('/tmp/etcd_client_cert.pem', '/tmp/etcd_client_key.pem'),
                        verify=False,
                        timeout=10
                    )

        # Construct content for etcd SRV Record
        recordcontent = construct_srv_record_content(config, etcdservers)

        # UPSERT the etcd SRV record with most recent list of records
        upsert_etcd_srv_record(route53, config, recordcontent)

        _LOGGER.info("Sync Complete")

    except Exception as e:
        _LOGGER.error(e)

if __name__ == '__main__':
    lambda_handler({}, {})
